#include <iostream>
#include <queue>
#include <string>
#include <filesystem>
#include <fstream>
#include <array>
#include <algorithm>
#include <unordered_set>

int32_t constexpr SZ = 141;
int32_t constexpr ASCII_OFFSET = 48;
using City_Blocks = std::array<std::array<int64_t, SZ>, SZ>;
using City_Blocks_With_Directions = std::array<std::array<std::array<int64_t, 4>, SZ>, SZ>;

enum Directions {
    RIGHT,
    LEFT,
    DOWN,
    UP,
    NO_DIR
};

struct Location {
    int16_t rows;
    int16_t cols;
    bool operator==(Location const &rhs) const {
        return this->rows == rhs.rows && this->cols == rhs.cols;
    }
};

// Lookup key: [current_direction][turn_direction (RIGHT or LEFT)]
static std::array<std::array<Directions, 2>, 4> turn_lookup {
    {
    // Right
        { DOWN, UP },
    // Left
        { UP, DOWN },
    // Down
        { LEFT, RIGHT },
    // Up
        { RIGHT, LEFT }
    }
};

inline Location move(Location loc, Directions dir) {
    switch (dir) {
        case Directions::RIGHT: {
            loc.cols++;
            break;
        }
        case Directions::LEFT: {
            loc.cols--;
            break;
        }
        case Directions::UP: {
            loc.rows--;
            break;
        }
        case Directions::DOWN: {
            loc.rows++;
            break;
        }
        default:
            break;
    }
    return loc;
}

template <class T>
inline void hash_combine(std::size_t & seed, const T & v)
{
    std::hash<T> hasher;
    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
struct Path_Node {
    Location loc;
    int8_t moves;
    Directions dir;
    int64_t heat_loss;
};

struct CompareNodes {
    bool operator()(Path_Node const &a, Path_Node const &b) const {
        return b.heat_loss < a.heat_loss;
    }
};

inline bool check_bounds(Location const &loc) {
    return loc.cols >= 0 && loc.cols < SZ && loc.rows >= 0 && loc.rows < SZ;
}


int cacheKey(Path_Node const &step) {
    auto [loc, steps, dir, heatLoss] = step;

    // return (x << (8 + 3 + 4)) | (y << (3 + 4)) | (dir << 4) | steps; // safer
    return (((loc.cols + 1) * 37 + (loc.rows + 1) * 17) * 5 + dir) * 9 + steps;
}

int64_t find_optimal_path(City_Blocks &cb) {
    // Prepare the cost map
    City_Blocks cost_map;
    for (auto &row: cost_map) {
        for (auto &col: row) {
            col = std::numeric_limits<int64_t>::max();
        }
    }

    // Create a queue and add starting points
    std::priority_queue<Path_Node, std::vector<Path_Node>, CompareNodes> q;
    Path_Node right = Path_Node { Location { 0, 0 }, 0, Directions::RIGHT, 0 };
    Path_Node down = Path_Node { Location { 0, 0 }, 0, Directions::DOWN, 0 };
    q.push(right);
    q.push(down);

    Path_Node current_node;
    std::unordered_set<int> visited {};
    visited.insert(cacheKey(right));
    visited.insert(cacheKey(down));
    auto find_node = [&visited] (Path_Node const &p) {
        return visited.contains(cacheKey(p));
    };


    // Explore paths
    while (!q.empty()) {
        current_node = q.top();
        q.pop();

        int16_t row = current_node.loc.rows;
        int16_t col = current_node.loc.cols;
        // If already at the end of the path, check if the cost of this path is lower than current and move on
        if (row == SZ - 1 && col == SZ - 1) {
            return current_node.heat_loss;
        }

        // If there's already a cost associated with this coordinate and current cost is not lower, skip adding nodes
        if (cost_map[row][col] <= current_node.heat_loss) {
            continue;
        } else {
            cost_map[row][col] = current_node.heat_loss;
        }


        // Explore paths
        // If there are remaining movement points, try moving in the same direction as previously
        if (current_node.moves < 3) {
            Location loc = move(current_node.loc, current_node.dir);
            if (check_bounds(loc)) {
                Path_Node p_n { loc,
                                static_cast<int8_t>(current_node.moves + 1),
                                current_node.dir,
                                current_node.heat_loss + cb[loc.rows][loc.cols] };
                if (auto key = cacheKey(p_n); !visited.contains(key)) {
                    q.push(p_n);
                    visited.insert(key);
                }
            }
        }
        Location loc_right = move(current_node.loc, turn_lookup[current_node.dir][Directions::RIGHT]);
        if (check_bounds(loc_right)) {
            Path_Node p_n_turn_right { loc_right,
                                       1, // Because invocation of move is already moving by 1
                                       turn_lookup[current_node.dir][Directions::RIGHT],
                                       current_node.heat_loss + cb[loc_right.rows][loc_right.cols] };
            if (auto key = cacheKey(p_n_turn_right); !visited.contains(key)) {
                q.push(p_n_turn_right);
                visited.insert(key);
            }
        }
                                   
        // If the node is in bounds after move, push it into the queue
        Location loc_left = move(current_node.loc, turn_lookup[current_node.dir][Directions::LEFT]);
        if (check_bounds(loc_left)) {
            Path_Node p_n_turn_left { loc_left,
                                  1, // Because invocation of move is already moving by 1
                                  turn_lookup[current_node.dir][Directions::LEFT],
                                  current_node.heat_loss + cb[loc_left.rows][loc_left.cols] };
            if (auto key = cacheKey(p_n_turn_left); !visited.contains(key)) {
                q.push(p_n_turn_left);
                visited.insert(key);
            }
        }
    }
    return cost_map[SZ - 1][SZ - 1];
}

int getLeastHeatLoss(City_Blocks const &map, const int minSteps, const int maxSteps) {
    constexpr int endX = SZ - 1;
    constexpr int endY = SZ - 1;

    Path_Node startingEast = {0, 0, 0, Directions::RIGHT, 0};
    Path_Node staringSouth = {0, 0, 0, Directions::DOWN, 0};

    std::priority_queue<Path_Node, std::vector<Path_Node>, CompareNodes> q;
    q.push(startingEast);
    q.push(staringSouth);

    std::unordered_set<int> visited;
    visited.insert(cacheKey(staringSouth));
    visited.insert(cacheKey(startingEast));
    while (!q.empty()) {
        const auto [loc, dir, heatLoss, steps] = q.top();
        q.pop();

        // cout << "X: " << x << " y: " << y << " dir: " << dir << " steps: " << steps << " heatLoss: " << heatLoss << endl;
        if (loc.cols == endX && loc.rows == endY) {
            if (steps < minSteps) continue;
            return heatLoss;
        }

        std::tuple<int, int, int> nextSteps[3];

        if (dir == Directions::UP) {
            nextSteps[0] = {loc.cols, loc.rows - 1, Directions::UP};
            nextSteps[1] = {loc.cols - 1, loc.rows, Directions::LEFT};
            nextSteps[2] = {loc.cols + 1, loc.rows, Directions::RIGHT};
        }
        if (dir == Directions::RIGHT) {
            nextSteps[0] = {loc.cols + 1, loc.rows, Directions::RIGHT};
            nextSteps[1] = {loc.cols, loc.rows + 1, Directions::DOWN};
            nextSteps[2] = {loc.cols, loc.rows - 1, Directions::UP};
        }
        if (dir == Directions::DOWN) {
            nextSteps[0] = {loc.cols, loc.rows + 1, Directions::DOWN};
            nextSteps[1] = {loc.cols - 1, loc.rows, Directions::LEFT};
            nextSteps[2] = {loc.cols + 1, loc.rows, Directions::RIGHT};
        }
        if (dir == Directions::LEFT) {
            nextSteps[0] = {loc.cols - 1, loc.rows, Directions::LEFT};
            nextSteps[1] = {loc.cols, loc.rows + 1, Directions::DOWN};
            nextSteps[2] = {loc.cols, loc.rows - 1, Directions::UP};
        }

        for (const auto [nx, ny, nDir]: nextSteps) {
            if (nx < 0 || ny < 0 || nx > endX || ny > endY) continue;
            if (steps > maxSteps - 1 && dir == nDir) continue;
            if (steps < minSteps && dir != nDir) continue;

            // const int nPrio = heatLoss + map[ny][nx] + (endX - nx + endY - ny);

            Path_Node next = {
                    static_cast<int16_t>(nx),
                    static_cast<int16_t>(ny),
                    static_cast<int8_t>((dir == nDir ? steps + 1 : 1)),
                    static_cast<Directions>(nDir),
                    (heatLoss + map[ny][nx])};

            if (auto key = cacheKey(next); visited.find(key) == visited.end()) {
                visited.insert(key);
                q.push(next);
            }
        }
    }

    return -1;
}


int32_t main() {
    City_Blocks city_blocks;
    std::filesystem::path file_path {"/home/t.talik/Programming/aoc2023/d17/input.txt"};
    std::fstream file_handle {file_path};
    std::string input {};
    for (int rows = 0; rows < SZ && std::getline(file_handle, input); ++rows) {
        for (int cols = 0; cols < SZ; ++cols) {
            city_blocks[rows][cols] = input.at(cols) - ASCII_OFFSET;
        }
    }

    for (auto &row: city_blocks) {
        for (auto &col: row) {
            std::cout << col;
        }
        std::cout << std::endl;
    }
    std::cout << getLeastHeatLoss(city_blocks, 1, 3) << std::endl;
    return 0;
}
